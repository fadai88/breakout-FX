def backtest_breakout_strategy(df, timeframe):
    # Calculate 50-day rolling high and low
    df['50_day_high'] = df['CLOSE'].rolling(window=50).max()
    df['50_day_low'] = df['CLOSE'].rolling(window=50).min()
    
    # Calculate ATR
    df['high_low'] = df['HIGH'] - df['LOW']
    df['high_close'] = abs(df['HIGH'] - df['CLOSE'].shift())
    df['low_close'] = abs(df['LOW'] - df['CLOSE'].shift())
    df['TR'] = pd.concat([df['high_low'], df['high_close'], df['low_close']], axis=1).max(axis=1)
    df['ATR'] = df['TR'].rolling(window=14).mean()
    
    # Initialize position and signals
    df['position'] = 0
    df['signal'] = 0
    df['returns'] = 0.0
    
    current_position = 0
    entry_price = 0
    trailing_stop = 0
    atr_multiplier = 2.0  # Adjust this value to change stop distance (e.g., 1.5, 2.0, 2.5)
    
    # Generate signals
    for i in range(50, len(df)):
        price = df.iloc[i]['CLOSE']
        high_50 = df.iloc[i-1]['50_day_high']
        low_50 = df.iloc[i-1]['50_day_low']
        current_atr = df.iloc[i]['ATR']
        
        if current_position == 0:
            if price > high_50:
                df.iloc[i, df.columns.get_loc('signal')] = 1
                current_position = 1
                entry_price = price
                trailing_stop = price - (current_atr * atr_multiplier)
            elif price < low_50:
                df.iloc[i, df.columns.get_loc('signal')] = -1
                current_position = -1
                entry_price = price
                trailing_stop = price + (current_atr * atr_multiplier)
        
        elif current_position == 1:
            # Update trailing stop for long positions
            new_stop = price - (current_atr * atr_multiplier)
            trailing_stop = max(trailing_stop, new_stop)
            
            # Check if price hits trailing stop
            if price < trailing_stop:
                df.iloc[i, df.columns.get_loc('signal')] = 0
                current_position = 0
        
        elif current_position == -1:
            # Update trailing stop for short positions
            new_stop = price + (current_atr * atr_multiplier)
            trailing_stop = min(trailing_stop, new_stop)
            
            # Check if price hits trailing stop
            if price > trailing_stop:
                df.iloc[i, df.columns.get_loc('signal')] = 0
                current_position = 0
        
        df.iloc[i, df.columns.get_loc('position')] = current_position

    # ... rest of the function remains the same ...
